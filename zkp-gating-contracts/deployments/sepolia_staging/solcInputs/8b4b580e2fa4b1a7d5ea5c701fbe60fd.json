{
  "language": "Solidity",
  "sources": {
    "@iden3/contracts/interfaces/ICircuitValidator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.16;\n\ninterface ICircuitValidator {\n    function verify(\n        uint256[] memory inputs,\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        bytes calldata data\n    ) external view;\n\n    function getSupportedCircuitIds() external view returns (string[] memory ids);\n\n    function inputIndexOf(string memory name) external view returns (uint256);\n}\n"
    },
    "@iden3/contracts/interfaces/IState.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.16;\n\nuint256 constant MAX_SMT_DEPTH = 64;\n\ninterface IState {\n    /**\n     * @dev Struct for public interfaces to represent a state information.\n     * @param id An identity.\n     * @param state A state.\n     * @param replacedByState A state, which replaced this state for the identity.\n     * @param createdAtTimestamp A time when the state was created.\n     * @param replacedAtTimestamp A time when the state was replaced by the next identity state.\n     * @param createdAtBlock A block number when the state was created.\n     * @param replacedAtBlock A block number when the state was replaced by the next identity state.\n     */\n    struct StateInfo {\n        uint256 id;\n        uint256 state;\n        uint256 replacedByState;\n        uint256 createdAtTimestamp;\n        uint256 replacedAtTimestamp;\n        uint256 createdAtBlock;\n        uint256 replacedAtBlock;\n    }\n\n    /**\n     * @dev Struct for public interfaces to represent GIST root information.\n     * @param root This GIST root.\n     * @param replacedByRoot A root, which replaced this root.\n     * @param createdAtTimestamp A time, when the root was saved to blockchain.\n     * @param replacedAtTimestamp A time, when the root was replaced by the next root in blockchain.\n     * @param createdAtBlock A number of block, when the root was saved to blockchain.\n     * @param replacedAtBlock A number of block, when the root was replaced by the next root in blockchain.\n     */\n    struct GistRootInfo {\n        uint256 root;\n        uint256 replacedByRoot;\n        uint256 createdAtTimestamp;\n        uint256 replacedAtTimestamp;\n        uint256 createdAtBlock;\n        uint256 replacedAtBlock;\n    }\n\n    /**\n     * @dev Struct for public interfaces to represent GIST proof information.\n     * @param root This GIST root.\n     * @param existence A flag, which shows if the leaf index exists in the GIST.\n     * @param siblings An array of GIST sibling node hashes.\n     * @param index An index of the leaf in the GIST.\n     * @param value A value of the leaf in the GIST.\n     * @param auxExistence A flag, which shows if the auxiliary leaf exists in the GIST.\n     * @param auxIndex An index of the auxiliary leaf in the GIST.\n     * @param auxValue An value of the auxiliary leaf in the GIST.\n     */\n    struct GistProof {\n        uint256 root;\n        bool existence;\n        uint256[MAX_SMT_DEPTH] siblings;\n        uint256 index;\n        uint256 value;\n        bool auxExistence;\n        uint256 auxIndex;\n        uint256 auxValue;\n    }\n\n    /**\n     * @dev Retrieve last state information of specific id.\n     * @param id An identity.\n     * @return The state info.\n     */\n    function getStateInfoById(uint256 id) external view returns (StateInfo memory);\n\n    /**\n     * @dev Retrieve state information by id and state.\n     * @param id An identity.\n     * @param state A state.\n     * @return The state info.\n     */\n    function getStateInfoByIdAndState(\n        uint256 id,\n        uint256 state\n    ) external view returns (StateInfo memory);\n\n    /**\n     * @dev Retrieve the specific GIST root information.\n     * @param root GIST root.\n     * @return The GIST root info.\n     */\n    function getGISTRootInfo(uint256 root) external view returns (GistRootInfo memory);\n\n    /**\n     * @dev Get defaultIdType\n     * @return defaultIdType\n     */\n    function getDefaultIdType() external view returns (bytes2);\n\n    /**\n     * @dev Performs state transition\n     * @param id Identifier of the identity\n     * @param oldState Previous state of the identity\n     * @param newState New state of the identity\n     * @param isOldStateGenesis Flag if previous identity state is genesis\n     * @param a Proof.A\n     * @param b Proof.B\n     * @param c Proof.C\n     */\n    function transitState(\n        uint256 id,\n        uint256 oldState,\n        uint256 newState,\n        bool isOldStateGenesis,\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c\n    ) external;\n\n    /**\n     * @dev Performs state transition\n     * @param id Identity\n     * @param oldState Previous identity state\n     * @param newState New identity state\n     * @param isOldStateGenesis Is the previous state genesis?\n     * @param methodId State transition method id\n     * @param methodParams State transition method-specific params\n     */\n    function transitStateGeneric(\n        uint256 id,\n        uint256 oldState,\n        uint256 newState,\n        bool isOldStateGenesis,\n        uint256 methodId,\n        bytes calldata methodParams\n    ) external;\n\n    /**\n     * @dev Check if identity exists.\n     * @param id Identity\n     * @return True if the identity exists\n     */\n    function idExists(uint256 id) external view returns (bool);\n\n    /**\n     * @dev Check if state exists.\n     * @param id Identity\n     * @param state State\n     * @return True if the state exists\n     */\n    function stateExists(uint256 id, uint256 state) external view returns (bool);\n}\n"
    },
    "@iden3/contracts/interfaces/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.16;\n\ninterface IVerifier {\n    function verify(\n        uint256[2] calldata a,\n        uint256[2][2] calldata b,\n        uint256[2] calldata c,\n        uint256[] calldata input\n    ) external view returns (bool r);\n}\n"
    },
    "@iden3/contracts/lib/GenesisUtils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.16;\n\nimport {PrimitiveTypeUtils} from \"./PrimitiveTypeUtils.sol\";\n\nlibrary GenesisUtils {\n    /**\n     *   @dev sum\n     */\n    function sum(bytes memory array) internal pure returns (uint16 s) {\n        require(array.length == 29, \"Checksum requires 29 length array\");\n\n        for (uint256 i = 0; i < array.length; ++i) {\n            s += uint16(uint8(array[i]));\n        }\n    }\n\n    /**\n     * @dev isGenesisState\n     */\n    function isGenesisState(uint256 id, uint256 idState) internal pure returns (bool) {\n        bytes2 idType = bytes2(\n            PrimitiveTypeUtils.uint256ToBytes(PrimitiveTypeUtils.reverseUint256(id))\n        );\n        uint256 computedId = calcIdFromGenesisState(idType, idState);\n        return id == computedId;\n    }\n\n    /**\n     * @dev calcIdFromGenesisState\n     */\n    function calcIdFromGenesisState(\n        bytes2 idType,\n        uint256 idState\n    ) internal pure returns (uint256) {\n        bytes memory userStateB1 = PrimitiveTypeUtils.uint256ToBytes(\n            PrimitiveTypeUtils.reverseUint256(idState)\n        );\n\n        bytes memory cutState = PrimitiveTypeUtils.slice(userStateB1, userStateB1.length - 27, 27);\n\n        bytes memory beforeChecksum = PrimitiveTypeUtils.concat(abi.encodePacked(idType), cutState);\n        require(beforeChecksum.length == 29, \"Checksum requires 29 length array\");\n\n        uint16 checksum = PrimitiveTypeUtils.reverseUint16(sum(beforeChecksum));\n\n        bytes memory checkSumBytes = abi.encodePacked(checksum);\n\n        bytes memory idBytes = PrimitiveTypeUtils.concat(beforeChecksum, checkSumBytes);\n        require(idBytes.length == 31, \"idBytes requires 31 length array\");\n\n        return PrimitiveTypeUtils.reverseUint256(PrimitiveTypeUtils.toUint256(idBytes));\n    }\n\n    /**\n     * @dev calcIdFromEthAddress\n     */\n    function calcIdFromEthAddress(bytes2 idType, address caller) internal pure returns (uint256) {\n        uint256 addr = PrimitiveTypeUtils.addressToUint256(caller);\n\n        return calcIdFromGenesisState(idType, PrimitiveTypeUtils.reverseUint256(addr));\n    }\n}\n"
    },
    "@iden3/contracts/lib/Poseidon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.16;\n\nlibrary PoseidonUnit1L {\n    function poseidon(uint256[1] calldata) public pure returns (uint256) {}\n}\n\nlibrary PoseidonUnit2L {\n    function poseidon(uint256[2] calldata) public pure returns (uint256) {}\n}\n\nlibrary PoseidonUnit3L {\n    function poseidon(uint256[3] calldata) public pure returns (uint256) {}\n}\n\nlibrary PoseidonUnit4L {\n    function poseidon(uint256[4] calldata) public pure returns (uint256) {}\n}\n\nlibrary PoseidonUnit5L {\n    function poseidon(uint256[5] calldata) public pure returns (uint256) {}\n}\n\nlibrary PoseidonUnit6L {\n    function poseidon(uint256[6] calldata) public pure returns (uint256) {}\n}\n\nlibrary SpongePoseidon {\n    uint32 internal constant BATCH_SIZE = 6;\n\n    function hash(uint256[] calldata values) public pure returns (uint256) {\n        uint256[BATCH_SIZE] memory frame = [uint256(0), 0, 0, 0, 0, 0];\n        bool dirty = false;\n        uint256 fullHash = 0;\n        uint32 k = 0;\n        for (uint32 i = 0; i < values.length; i++) {\n            dirty = true;\n            frame[k] = values[i];\n            if (k == BATCH_SIZE - 1) {\n                fullHash = PoseidonUnit6L.poseidon(frame);\n                dirty = false;\n                frame = [uint256(0), 0, 0, 0, 0, 0];\n                frame[0] = fullHash;\n                k = 1;\n            } else {\n                k++;\n            }\n        }\n        if (dirty) {\n            // we haven't hashed something in the main sponge loop and need to do hash here\n            fullHash = PoseidonUnit6L.poseidon(frame);\n        }\n        return fullHash;\n    }\n}\n\nlibrary PoseidonFacade {\n    function poseidon1(uint256[1] calldata el) public pure returns (uint256) {\n        return PoseidonUnit1L.poseidon(el);\n    }\n\n    function poseidon2(uint256[2] calldata el) public pure returns (uint256) {\n        return PoseidonUnit2L.poseidon(el);\n    }\n\n    function poseidon3(uint256[3] calldata el) public pure returns (uint256) {\n        return PoseidonUnit3L.poseidon(el);\n    }\n\n    function poseidon4(uint256[4] calldata el) public pure returns (uint256) {\n        return PoseidonUnit4L.poseidon(el);\n    }\n\n    function poseidon5(uint256[5] calldata el) public pure returns (uint256) {\n        return PoseidonUnit5L.poseidon(el);\n    }\n\n    function poseidon6(uint256[6] calldata el) public pure returns (uint256) {\n        return PoseidonUnit6L.poseidon(el);\n    }\n\n    function poseidonSponge(uint256[] calldata el) public pure returns (uint256) {\n        return SpongePoseidon.hash(el);\n    }\n}\n"
    },
    "@iden3/contracts/lib/PrimitiveTypeUtils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.16;\n\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nlibrary PrimitiveTypeUtils {\n    /**\n     * @dev uint256ToBytes\n     */\n    function uint256ToBytes(uint256 x) internal pure returns (bytes memory b) {\n        b = new bytes(32);\n        assembly {\n            mstore(add(b, 32), x)\n        }\n    }\n\n    /**\n     * @dev reverse uint256\n     */\n    function reverseUint256(uint256 input) internal pure returns (uint256 v) {\n        v = input;\n\n        // swap bytes\n        v =\n            ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n\n        // swap 2-byte long pairs\n        v =\n            ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n\n        // swap 4-byte long pairs\n        v =\n            ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32) |\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n\n        // swap 8-byte long pairs\n        v =\n            ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64) |\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n\n        // swap 16-byte long pairs\n        v = (v >> 128) | (v << 128);\n    }\n\n    /**\n     * @dev reverse uint16\n     */\n    function reverseUint16(uint16 input) internal pure returns (uint16 v) {\n        v = input;\n\n        // swap bytes\n        v = (v >> 8) | (v << 8);\n    }\n\n    /**\n     * @dev reverse uint32\n     */\n    function reverseUint32(uint32 input) internal pure returns (uint32 v) {\n        v = input;\n\n        // swap bytes\n        v = ((v & 0xFF00FF00) >> 8) | ((v & 0x00FF00FF) << 8);\n\n        // swap 2-byte long pairs\n        v = (v >> 16) | (v << 16);\n    }\n\n    /**\n     * @dev compareStrings\n     */\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        if (bytes(a).length != bytes(b).length) {\n            return false;\n        }\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n\n    /**\n     * @dev toUint256\n     */\n    function toUint256(bytes memory bys) internal pure returns (uint256 value) {\n        assembly {\n            value := mload(add(bys, 0x20))\n        }\n    }\n\n    /**\n     * @dev bytesToAddress\n     */\n    function bytesToAddress(bytes memory bys) internal pure returns (address addr) {\n        assembly {\n            addr := mload(add(bys, 20))\n        }\n    }\n\n    /**\n     * @dev int256ToAddress\n     */\n    function int256ToAddress(uint256 input) internal pure returns (address) {\n        return bytesToAddress(uint256ToBytes(reverseUint256(input)));\n    }\n\n    /**\n     * @dev concat\n     */\n    function concat(\n        bytes memory preBytes,\n        bytes memory postBytes\n    ) internal pure returns (bytes memory) {\n        return BytesLib.concat(preBytes, postBytes);\n    }\n\n    /**\n     * @dev slice\n     */\n    function slice(\n        bytes memory bys,\n        uint256 start,\n        uint256 length\n    ) internal pure returns (bytes memory) {\n        return BytesLib.slice(bys, start, length);\n    }\n\n    /**\n     * @dev addressToUint256\n     */\n    function addressToUint256(address _addr) internal pure returns (uint256) {\n        return uint256(uint160(_addr));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/validators/CredentialAtomicQueryMTPValidator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\nimport {CredentialAtomicQueryValidator} from \"./CredentialAtomicQueryValidator.sol\";\nimport {IVerifier} from \"@iden3/contracts/interfaces/IVerifier.sol\";\n\ncontract CredentialAtomicQueryMTPValidator is CredentialAtomicQueryValidator {\n    /**\n     * @dev Version of contract\n     */\n    string public constant VERSION = \"1.0.1\";\n\n    string internal constant CIRCUIT_ID = \"credentialAtomicQueryMTPV2OnChain\";\n\n    // This empty reserved space is put in place to allow future versions\n    // of the CredentialAtomicQuerySigValidator contract to inherit from other contracts without a risk of\n    // breaking the storage layout. This is necessary because the parent contracts in the\n    // future may introduce some storage variables, which are placed before the CredentialAtomicQuerySigValidator\n    // contract's storage variables.\n    // (see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#storage-gaps)\n    // slither-disable-next-line shadowing-state\n    // slither-disable-next-line unused-state\n    uint256[500] private __gap_before;\n\n    // PUT NEW STATE VARIABLES HERE\n\n    // This empty reserved space is put in place to allow future versions\n    // of this contract to add new variables without shifting down\n    // storage of child contracts that use this contract as a base\n    // (see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#storage-gaps)\n    uint256[50] __gap_after;\n\n    function initialize(\n        address _verifierContractAddr,\n        address _stateContractAddr\n    ) public override initializer {\n        _setInputToIndex(\"merklized\", 0);\n        _setInputToIndex(\"userID\", 1);\n        _setInputToIndex(\"circuitQueryHash\", 2);\n        _setInputToIndex(\"requestID\", 3);\n        _setInputToIndex(\"challenge\", 4);\n        _setInputToIndex(\"gistRoot\", 5);\n        _setInputToIndex(\"issuerID\", 6);\n        _setInputToIndex(\"issuerClaimIdenState\", 7);\n        _setInputToIndex(\"isRevocationChecked\", 8);\n        _setInputToIndex(\"issuerClaimNonRevState\", 9);\n        _setInputToIndex(\"timestamp\", 10);\n        _supportedCircuitIds = [CIRCUIT_ID];\n        _circuitIdToVerifier[CIRCUIT_ID] = IVerifier(_verifierContractAddr);\n        super.initialize(_verifierContractAddr, _stateContractAddr);\n    }\n\n    function verify(\n        uint256[] calldata inputs,\n        uint256[2] calldata a,\n        uint256[2][2] calldata b,\n        uint256[2] calldata c,\n        bytes calldata data\n    ) external view virtual {\n        _verify(inputs, a, b, c, data);\n    }\n\n    function parseCommonPubSignals(\n        uint256[] calldata inputs\n    ) public pure override returns (CommonPubSignals memory) {\n        CommonPubSignals memory params = CommonPubSignals({\n            merklized: inputs[0],\n            userID: inputs[1],\n            circuitQueryHash: inputs[2],\n            requestID: inputs[3],\n            challenge: inputs[4],\n            gistRoot: inputs[5],\n            issuerID: inputs[6],\n            issuerState: inputs[7],\n            isRevocationChecked: inputs[8],\n            issuerClaimNonRevState: inputs[9],\n            timestamp: inputs[10]\n        });\n\n        return params;\n    }\n}\n"
    },
    "contracts/validators/CredentialAtomicQuerySigValidator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\nimport {CredentialAtomicQueryValidator} from \"./CredentialAtomicQueryValidator.sol\";\nimport {IVerifier} from \"@iden3/contracts/interfaces/IVerifier.sol\";\n\ncontract CredentialAtomicQuerySigValidator is CredentialAtomicQueryValidator {\n    /**\n     * @dev Version of contract\n     */\n    string public constant VERSION = \"1.0.1\";\n\n    string internal constant CIRCUIT_ID = \"credentialAtomicQuerySigV2OnChain\";\n\n    // This empty reserved space is put in place to allow future versions\n    // of the CredentialAtomicQuerySigValidator contract to inherit from other contracts without a risk of\n    // breaking the storage layout. This is necessary because the parent contracts in the\n    // future may introduce some storage variables, which are placed before the CredentialAtomicQuerySigValidator\n    // contract's storage variables.\n    // (see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#storage-gaps)\n    // slither-disable-next-line shadowing-state\n    // slither-disable-next-line unused-state\n    uint256[500] private __gap_before;\n\n    // PUT NEW STATE VARIABLES HERE\n\n    // This empty reserved space is put in place to allow future versions\n    // of this contract to add new variables without shifting down\n    // storage of child contracts that use this contract as a base\n    // (see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#storage-gaps)\n    uint256[50] __gap_after;\n\n    function initialize(\n        address _verifierContractAddr,\n        address _stateContractAddr\n    ) public override initializer {\n        _setInputToIndex(\"merklized\", 0);\n        _setInputToIndex(\"userID\", 1);\n        _setInputToIndex(\"circuitQueryHash\", 2);\n        _setInputToIndex(\"issuerAuthState\", 3);\n        _setInputToIndex(\"requestID\", 4);\n        _setInputToIndex(\"challenge\", 5);\n        _setInputToIndex(\"gistRoot\", 6);\n        _setInputToIndex(\"issuerID\", 7);\n        _setInputToIndex(\"isRevocationChecked\", 8);\n        _setInputToIndex(\"issuerClaimNonRevState\", 9);\n        _setInputToIndex(\"timestamp\", 10);\n        _supportedCircuitIds = [CIRCUIT_ID];\n        _circuitIdToVerifier[CIRCUIT_ID] = IVerifier(_verifierContractAddr);\n        super.initialize(_verifierContractAddr, _stateContractAddr);\n    }\n\n    function verify(\n        uint256[] calldata inputs,\n        uint256[2] calldata a,\n        uint256[2][2] calldata b,\n        uint256[2] calldata c,\n        bytes calldata data\n    ) external view virtual {\n        _verify(inputs, a, b, c, data);\n    }\n\n    function parseCommonPubSignals(\n        uint256[] calldata inputs\n    ) public pure override returns (CommonPubSignals memory) {\n        CommonPubSignals memory params = CommonPubSignals({\n            merklized: inputs[0],\n            userID: inputs[1],\n            circuitQueryHash: inputs[2],\n            issuerState: inputs[3],\n            requestID: inputs[4],\n            challenge: inputs[5],\n            gistRoot: inputs[6],\n            issuerID: inputs[7],\n            isRevocationChecked: inputs[8],\n            issuerClaimNonRevState: inputs[9],\n            timestamp: inputs[10]\n        });\n\n        return params;\n    }\n}\n"
    },
    "contracts/validators/CredentialAtomicQueryValidator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {GenesisUtils} from \"@iden3/contracts/lib/GenesisUtils.sol\";\nimport {ICircuitValidator} from \"@iden3/contracts/interfaces/ICircuitValidator.sol\";\nimport {IVerifier} from \"@iden3/contracts/interfaces/IVerifier.sol\";\nimport {IState} from \"@iden3/contracts/interfaces/IState.sol\";\nimport {PoseidonFacade} from \"@iden3/contracts/lib/Poseidon.sol\";\n\nabstract contract CredentialAtomicQueryValidator is\n    OwnableUpgradeable,\n    ICircuitValidator\n{\n    struct CredentialAtomicQuery {\n        uint256 schema;\n        uint256 claimPathKey;\n        uint256 operator;\n        uint256 slotIndex;\n        uint256[] value;\n        uint256 queryHash;\n        uint256[] allowedIssuers;\n        string[] circuitIds;\n        bool skipClaimRevocationCheck;\n        // 0 for inclusion in merklized credentials, 1 for non-inclusion and for non-merklized credentials\n        uint256 claimPathNotExists;\n    }\n\n    struct CommonPubSignals {\n        uint256 merklized;\n        uint256 userID;\n        uint256 issuerState;\n        uint256 circuitQueryHash;\n        uint256 requestID;\n        uint256 challenge;\n        uint256 gistRoot;\n        uint256 issuerID;\n        uint256 isRevocationChecked;\n        uint256 issuerClaimNonRevState;\n        uint256 timestamp;\n    }\n\n    // This empty reserved space is put in place to allow future versions\n    // of the CredentialAtomicQuerySigValidator contract to inherit from other contracts without a risk of\n    // breaking the storage layout. This is necessary because the parent contracts in the\n    // future may introduce some storage variables, which are placed before the CredentialAtomicQuerySigValidator\n    // contract's storage variables.\n    // (see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#storage-gaps)\n    // slither-disable-next-line shadowing-state\n    // slither-disable-next-line unused-state\n    uint256[500] private __gap_before_base;\n\n    mapping(string => IVerifier) internal _circuitIdToVerifier;\n    string[] internal _supportedCircuitIds;\n\n    IState public state;\n\n    uint256 public revocationStateExpirationTimeout;\n    uint256 public proofExpirationTimeout;\n    uint256 public gistRootExpirationTimeout;\n\n    mapping(string => uint256) internal _inputNameToIndex;\n\n    // This empty reserved space is put in place to allow future versions\n    // of this contract to add new variables without shifting down\n    // storage of child contracts that use this contract as a base\n    // (see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#storage-gaps)\n    uint256[43] __gap_after_base;\n\n    function initialize(\n        address _verifierContractAddr,\n        address _stateContractAddr\n    ) public virtual onlyInitializing {\n        revocationStateExpirationTimeout = 1 hours;\n        proofExpirationTimeout = 1 hours;\n        gistRootExpirationTimeout = 1 hours;\n        state = IState(_stateContractAddr);\n        __Ownable_init();\n    }\n\n    function parseCommonPubSignals(\n        uint256[] calldata inputs\n    ) public pure virtual returns (CommonPubSignals memory);\n\n    function setRevocationStateExpirationTimeout(\n        uint256 expirationTimeout\n    ) public virtual onlyOwner {\n        revocationStateExpirationTimeout = expirationTimeout;\n    }\n\n    function setProofExpirationTimeout(\n        uint256 expirationTimeout\n    ) public virtual onlyOwner {\n        proofExpirationTimeout = expirationTimeout;\n    }\n\n    function setGISTRootExpirationTimeout(\n        uint256 expirationTimeout\n    ) public virtual onlyOwner {\n        gistRootExpirationTimeout = expirationTimeout;\n    }\n\n    function setStateAddress(\n        address stateContractAddr\n    ) public virtual onlyOwner {\n        state = IState(stateContractAddr);\n    }\n\n    function getSupportedCircuitIds()\n        external\n        view\n        virtual\n        returns (string[] memory ids)\n    {\n        return _supportedCircuitIds;\n    }\n\n    function inputIndexOf(\n        string memory name\n    ) external view virtual returns (uint256) {\n        uint256 index = _inputNameToIndex[name];\n        require(index != 0, \"Input name not found\");\n        return --index; // we save 1-based index, but return 0-based\n    }\n\n    function _verify(\n        uint256[] calldata inputs,\n        uint256[2] calldata a,\n        uint256[2][2] calldata b,\n        uint256[2] calldata c,\n        bytes calldata data\n    ) internal view virtual {\n        CredentialAtomicQuery memory credAtomicQuery = abi.decode(\n            data,\n            (CredentialAtomicQuery)\n        );\n        IVerifier verifier = _circuitIdToVerifier[\n            credAtomicQuery.circuitIds[0]\n        ];\n\n        require(\n            credAtomicQuery.circuitIds.length == 1 &&\n                verifier != IVerifier(address(0)),\n            \"Invalid circuit ID\"\n        );\n\n        // verify that zkp is valid\n        require(verifier.verify(a, b, c, inputs), \"Proof is not valid\");\n\n        CommonPubSignals memory signals = parseCommonPubSignals(inputs);\n\n        // check circuitQueryHash\n        require(\n            signals.circuitQueryHash == credAtomicQuery.queryHash,\n            \"Query hash does not match the requested one\"\n        );\n\n        // TODO: add support for query to specific userID and then verifying it\n\n        _checkMerklized(signals.merklized, credAtomicQuery.claimPathKey);\n        // TODO: fix this ('Root does not exist')\n        //_checkGistRoot(signals.gistRoot);\n        _checkAllowedIssuers(signals.issuerID, credAtomicQuery.allowedIssuers);\n        _checkClaimIssuanceState(signals.issuerID, signals.issuerState);\n        // TODO: handle revocation state\n        //_checkClaimNonRevState(signals.issuerID, signals.issuerClaimNonRevState);\n        // TODO: handle proof expiration\n        // _checkProofExpiration(signals.timestamp);\n        // TODO: handle revocation state\n        // _checkIsRevocationChecked(\n        //   signals.isRevocationChecked,\n        //   credAtomicQuery.skipClaimRevocationCheck\n        // );\n    }\n\n    function _checkGistRoot(uint256 gistRoot) internal view {\n        IState.GistRootInfo memory rootInfo = state.getGISTRootInfo(gistRoot);\n        require(\n            rootInfo.root == gistRoot,\n            \"Gist root state isn't in state contract\"\n        );\n        if (\n            rootInfo.replacedAtTimestamp != 0 &&\n            block.timestamp - rootInfo.replacedAtTimestamp >\n            gistRootExpirationTimeout\n        ) {\n            revert(\"Gist root is expired\");\n        }\n    }\n\n    function _checkClaimIssuanceState(\n        uint256 _id,\n        uint256 _state\n    ) internal view {\n        bool isStateGenesis = GenesisUtils.isGenesisState(_id, _state);\n\n        if (!isStateGenesis) {\n            IState.StateInfo memory stateInfo = state.getStateInfoByIdAndState(\n                _id,\n                _state\n            );\n            require(\n                _id == stateInfo.id,\n                \"State doesn't exist in state contract\"\n            );\n        }\n    }\n\n    function _checkClaimNonRevState(\n        uint256 _id,\n        uint256 _claimNonRevState\n    ) internal view {\n        // check if identity transited any state in contract\n        bool idExists = state.idExists(_id);\n\n        // if identity didn't transit any state it must be genesis\n        if (!idExists) {\n            require(\n                GenesisUtils.isGenesisState(_id, _claimNonRevState),\n                \"Issuer revocation state doesn't exist in state contract and is not genesis\"\n            );\n        } else {\n            IState.StateInfo memory claimNonRevStateInfo = state\n                .getStateInfoById(_id);\n            // The non-empty state is returned, and it's not equal to the state that the user has provided.\n            if (claimNonRevStateInfo.state != _claimNonRevState) {\n                // Get the time of the latest state and compare it to the transition time of state provided by the user.\n                IState.StateInfo memory claimNonRevLatestStateInfo = state\n                    .getStateInfoByIdAndState(_id, _claimNonRevState);\n\n                if (\n                    claimNonRevLatestStateInfo.id == 0 ||\n                    claimNonRevLatestStateInfo.id != _id\n                ) {\n                    revert(\"State in transition info contains invalid id\");\n                }\n\n                if (claimNonRevLatestStateInfo.replacedAtTimestamp == 0) {\n                    revert(\n                        \"Non-Latest state doesn't contain replacement information\"\n                    );\n                }\n\n                if (\n                    block.timestamp -\n                        claimNonRevLatestStateInfo.replacedAtTimestamp >\n                    revocationStateExpirationTimeout\n                ) {\n                    revert(\"Non-Revocation state of Issuer expired\");\n                }\n            }\n        }\n    }\n\n    function _checkProofExpiration(\n        uint256 _proofGenerationTimestamp\n    ) internal view {\n        if (_proofGenerationTimestamp > block.timestamp) {\n            revert(\"Proof generated in the future is not valid\");\n        }\n        if (\n            block.timestamp - _proofGenerationTimestamp > proofExpirationTimeout\n        ) {\n            revert(\"Generated proof is outdated\");\n        }\n    }\n\n    function _checkAllowedIssuers(\n        uint256 issuerId,\n        uint256[] memory allowedIssuers\n    ) internal pure {\n        // empty array is 'allow all' equivalent - ['*']\n        if (allowedIssuers.length == 0) {\n            return;\n        }\n\n        for (uint i = 0; i < allowedIssuers.length; i++) {\n            if (issuerId == allowedIssuers[i]) {\n                return;\n            }\n        }\n\n        revert(\"Issuer is not on the Allowed Issuers list\");\n    }\n\n    function _checkMerklized(\n        uint256 merklized,\n        uint256 queryClaimPathKey\n    ) internal pure {\n        uint256 shouldBeMerklized = queryClaimPathKey != 0 ? 1 : 0;\n        require(\n            merklized == shouldBeMerklized,\n            \"Merklized value is not correct\"\n        );\n    }\n\n    function _checkIsRevocationChecked(\n        uint256 isRevocationChecked,\n        bool skipClaimRevocationCheck\n    ) internal pure {\n        uint256 expectedIsRevocationChecked = 1;\n        if (skipClaimRevocationCheck) {\n            expectedIsRevocationChecked = 0;\n        }\n        require(\n            isRevocationChecked == expectedIsRevocationChecked,\n            \"Revocation check should match the query\"\n        );\n    }\n\n    function _setInputToIndex(string memory inputName, uint256 index) internal {\n        _inputNameToIndex[inputName] = ++index; // increment index to avoid 0\n    }\n}\n"
    },
    "solidity-bytes-utils/contracts/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equal_nonAligned(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let endMinusWord := add(_preBytes, length)\n                let mc := add(_preBytes, 0x20)\n                let cc := add(_postBytes, 0x20)\n\n                for {\n                // the next line is the loop condition:\n                // while(uint256(mc < endWord) + cb == 2)\n                } eq(add(lt(mc, endMinusWord), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n\n                // Only if still successful\n                // For <1 word tail bytes\n                if gt(success, 0) {\n                    // Get the remainder of length/32\n                    // length % 32 = AND(length, 32 - 1)\n                    let numTailBytes := and(length, 0x1f)\n                    let mcRem := mload(mc)\n                    let ccRem := mload(cc)\n                    for {\n                        let i := 0\n                    // the next line is the loop condition:\n                    // while(uint256(i < numTailBytes) + cb == 2)\n                    } eq(add(lt(i, numTailBytes), cb), 2) {\n                        i := add(i, 1)\n                    } {\n                        if iszero(eq(byte(i, mcRem), byte(i, ccRem))) {\n                            // unsuccess:\n                            success := 0\n                            cb := 0\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true
      }
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}